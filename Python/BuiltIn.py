'''Python 2.7's built-in functions and types.Function documentation from built-in docstringsprinted in IPython. Note that optional argumentsare displayed in brackets in these docstrings,e.g., function(formal_arg1[, optional_arg]) meansthat optional_arg is optional, as are the commaand whitespace preceeding it.'''##   TRUE TYPES##    data types# complex'''Create a complex number from a real part and   an optional imaginary part. This is equivalent   to (real + imag*1j) where imag defaults to 0.   complex(real[, imag]) --> complex number   '''complex(1)      # returns (1+0j)complex(1, 1)   # returns (1+1j)complex(0, 0)   # returns 0jcomplex(0, 1)   # returns 1j    # useful methodsfoo = complex(1, 2) # (1+2j)foo.conjugate()     # (1-2j), complex conjugatefoo.real            # 1.0, foo's real componentfoo.imag            # 2.0, foo's imaginary component# float'''Convert a string or number to a floating point    number, if possible.      float(x) --> floating point number   '''float(5)    # returns 5.0float(5.0)  # returns 5.0float('5')  # returns 5.0float(complex(1)) # returns TypeError: can't convert complex to float    # useful methodsfoo = 0.75foo.as_integer_ratio()  # returns (3, 4)foo.conjugate()         # returns foo, its own complex conjugatefoo.hex()               # returns '0x1.8000000000000p-1', a hexadecimal representation of foofoo.imag                # returns 0, foo's imaginary componentfoo.real                # returns foo, foo's real componentfoo.is_integer()        # returns False, because foo is not equal to any integer# int'''Convert a string or number to an integer, if possible.  A floating point   argument will be truncated towards zero (this does not include a string   representation of a floating point number!)  When converting a string, use   the optional base.  It is an error to supply a base when converting a   non-string.  If base is zero, the proper base is guessed based on the   string content.  If the argument is outside the integer range a   long object will be returned instead.      int(x[, base]) --> integer   '''int(5.0)    # returns 5int(5.999)  # returns 5int('5')    # returns 5int('5.')   # returns ValueError: invalid literal for int() with base 10: '5.'int(complex(0)) # returns TypeError: can't convert complex to int    # useful methodsfoo = 5foo.bit_length()        # returns 3, the number of bits needed to represent foo in binary# str'''Return a nice string representation of the object.   If the argument is a string, the return value is the same object.      str(object) --> string   '''str(5)        # returns '5'str(5.)       # returns '5.0'str(5.0)      # returns '5.0'str('string') # returns 'string'str([])       # returns '[]'str((1,2,3))  # returns '(1,2,3)'str(str)      # returns "<type 'str'>"# the following returns True # (compares literal string to Unicode string, #  see unicode type below)'' == u''    # useful methodsfoo = 'string'foo.capitalize()         # returns 'String'foo.center(9)            # returns '  string ', a string of length 10 with foo centered as much as possiblefoo.count('str')         # returns 1, the no. of times that 'str' occurs in foofoo.decode()             # returns u'string'. You can specify an encoding to use and error handling behavior.foo.encode()             # returns 'string'. " " " " "foo.endswith('ing')      # returns True, bc foo ends in 'ing'. 'ing' could also be a tuple of strings to try.foo.expandtabs(90000)    # returns 'string'. This replaces tabs with 90000 characters; by default, leave blank for 8.foo.find('ing')          # returns 3, the lowest index where 'ing' is found in foofoo.isalpha()            # returns True, bc all chars in foo are alphabeticalfoo.isdigit()            # returns False, bc not all chars in foo are numericfoo.isalnum()            # returns False, bc foo does not contain at least 1 alphabetical char and at least 1 number (foo is not alphanumeric)foo.islower()            # returns True, bc all chars in foo are lower casefoo.isupper()            # returns false, bc not all chars in foo are upper casefoo.istitle()            # returns false, bc foo's first char is not capitalized ('String'.istitle() is True)foo.isspace()            # returns false, bc foo does not contain all whitespacefoo.join('123')          # returns '1string2string3' by using foo to join each element in the iterable (can be any iterable!)foo.ljust(10)            # returns 'string    ', a string of length 10 with foo left-justified in itfoo.lower()              # returns 'string', foo in lower casefoo.lstrip('str')        # returns 'ing' by removing whitespace or the input string (which is 'str' here) from the left side of the string, nowhere elsefoo.partition('ri')      # returns ('st','ri','ng') by getting what's left of 'ri', 'ri' and what's right of 'ri'foo.replace('s', '5', 1) # returns '5tring' by replacing 's' with '5', a maximum of 1 timefoo.rfind('ing')         # returns 3 by finding the highest index (as opposed to lfind's lowest index) where 'ing' occurs in foofoo.rjust(10)            # returns '    string', a string of length 10 with foo right-justified in itfoo.rpartition('ri')     # returns ('st', 'ri', 'ng') by starting from the right, finding 'ri' and getting it and the adjacent strings.foo.rsplit('ri', 1)      # returns ['st','ng'] by starting from the right, finding 'ri' and splitting foo 1 timefoo.rstrip('ing')        # returns 'str' by starting from the right, finding 'ing' and removing itfoo.split('ri', 1)       # returns ['st', 'ng'] by starting from the left, finding 'ri' and splitting foo 1 time'\n1\n'.splitlines(True) # returns ['\n', '1\n'] by splitting at newlines. True says 'keep newline chars', and is optional. By default, newline chars are removed.foo.startswith('str')    # returns Truefoo.strip('st')          # returns 'ring'foo.swapcase()           # returns 'STRING' by swapping the case for each character in foofoo.title()              # returns 'String' by capitalizing the first char and lower-casing all other chars in foofoo.upper()              # returns 'STRING' by making all characters upper case in foofoo.zfill(10)            # returns '0000string' by padding foo on the left until a string of length 10 is made# slice'''Create a slice object.     This is used for extended slicing (e.g. a[0:10:2]).      slice([start,] stop[, step]) --> slice object   '''slice(5)        # returns slice(None, 5, None)slice(0, 5)     # returns slice(0, 5, None)slice(0, 5, 2)  # return slice(0, 5, 2)[0,1,2,3,4,5][slice(0,5,2)] # returns [0,2,4][0,1,2,3,4,5][0:5:2]        # returns [0,2,4]    # useful methodsfoo = slice(0, 10, 2)foo.indices(10)         # returns (0, 10, 2) by finding (startIndex, endIndex, stride) in a sequence of length 10foo.start               # returns 0foo.stop                # returns 10foo.step                # returns 2# type'''type(object) --> the object's type   type(name, bases, dict) --> a new type   '''type('5')   # returns <type 'str'>type(5.0)   # returns <type 'float'>type(type)  # returns <type 'type'>if type(5.) == type(5.0): # True    '5. and 5.0 have the same type'# unicode'''Create a new Unicode object from the given encoded string.   encoding defaults to the current default string encoding.   errors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.      unicode(string [, encoding[, errors]]) --> object   '''   # See this for help: See this for help: http://docs.python.org/howto/unicode.htmlunicode('string')   # returns u'string'unicode(u'string')  # returns u'string'unicode(5)          # returns u'5'unicode(5.)         # returns u'5.0'    # useful methods -- shares many with str, with some notable additionsfoo = u'12345'foo.isdecimal()     # returns Truefoo.isnumeric()     # returns True#    data containers# list# dict# tuple# set# frozenset##   FUNCTIONS## all  # abs              # apply            # any              # bin              # callable         # chr              # cmp              # coerce           # compile          # delattr          # divmod           # dreload          # execfile         # filter           # format           # getattr          # globals          # hasattr          # hash             # hex              # id               # intern           # isinstance       # iter             # len              # locals           # map              # max              # min              # next             # oct              # open             # ord              # pow              # range            # raw_input        # reduce           # reload           # repr             # round            # setattr          # sorted           # sum              # unichr           # vars             # zip##   OTHER TYPE-FUNCTION OBJECTS## classmethod# enumerate  # file'''Open a file.  The mode can be 'r', 'w' or 'a' for reading (default),   writing or appending.  The file will be created if it doesn't exist   when opened for writing or appending; it will be truncated when   opened for writing.  Add a 'b' to the mode for binary files.   Add a '+' to the mode to allow simultaneous reading and writing.   If the buffering argument is given, 0 means unbuffered, 1 means line   buffered, and larger numbers specify the buffer size.  The preferred way <----- NB!   to open a file is with the builtin open() function.                      <----/   Add a 'U' to mode to open the file for input with universal newline   support.  Any line ending in the input file will be seen as a '\n'   in Python.  Also, a file so opened gains the attribute 'newlines';   the value for this attribute is one of None (no newline read yet),   '\r', '\n', '\r\n' or a tuple containing all the newline types seen.      'U' cannot be combined with 'w' or '+' mode.      file(name[, mode[, buffering]]) -> file object   '''# reversed   # super      # xrange     