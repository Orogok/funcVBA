'''Python 2.7's built-in functions and types.Function documentation from built-in docstringsprinted in IPython. Note that optional argumentsare displayed in brackets in these docstrings,e.g., function(formal_arg1[, optional_arg]) meansthat optional_arg is optional, as are the commaand whitespace preceeding it.PYTHON DOCUMENTATION -- ALL BUILT-IN FUNCTIONS:http://docs.python.org/library/functions.html#built-in-functions'''#===============================================================================#   TYPES#===============================================================================#                      ---DATA TYPES---# complex'''Create a complex number from a real part and   an optional imaginary part. This is equivalent   to (real + imag*1j) where imag defaults to 0.   complex(real[, imag]) --> complex number      http://docs.python.org/library/functions.html#complex   '''complex(1)      # returns (1+0j)complex(1, 1)   # returns (1+1j)complex(0, 0)   # returns 0jcomplex(0, 1)   # returns 1j    # useful methodsfoo = complex(1, 2) # (1+2j)foo.conjugate()     # (1-2j), complex conjugatefoo.real            # 1.0, foo's real componentfoo.imag            # 2.0, foo's imaginary component#-------------------------------------------------------------------------------# float'''Convert a string or number to a floating point    number, if possible.      float(x) --> floating point number      http://docs.python.org/library/functions.html#float   '''float(5)                # returns 5.0float(5.0)              # returns 5.0float('5')              # returns 5.0float(complex(1))       # returns TypeError: can't convert complex to float    # useful methodsfoo = 0.75foo.as_integer_ratio()  # returns (3, 4)foo.conjugate()         # returns foo, its own complex conjugatefoo.hex()               # returns '0x1.8000000000000p-1', a hexadecimal                         # representation of foofoo.imag                # returns 0, foo's imaginary componentfoo.real                # returns foo, foo's real componentfoo.is_integer()        # returns False, because foo is not equal to any integer#-------------------------------------------------------------------------------# int'''Convert a string or number to an integer, if possible.  A floating point   argument will be truncated towards zero (this does not include a string   representation of a floating point number!)  When converting a string, use   the optional base.  It is an error to supply a base when converting a   non-string.  If base is zero, the proper base is guessed based on the   string content.  If the argument is outside the integer range a   long object will be returned instead.      int(x[, base]) --> integer      http://docs.python.org/library/functions.html#int   '''int(5.0)    # returns 5int(5.999)  # returns 5int('5')    # returns 5int('5.')   # returns ValueError: invalid literal for int() with base 10: '5.'int(complex(0)) # returns TypeError: can't convert complex to int    # useful methodsfoo = 5foo.bit_length()        # returns 3, the number of bits needed                         # to represent foo in binary#-------------------------------------------------------------------------------# str'''Return a nice string representation of the object.   If the argument is a string, the return value is the same object.      str(object) --> string      http://docs.python.org/library/functions.html#str   '''str(5)        # returns '5'str(5.)       # returns '5.0'str(5.0)      # returns '5.0'str('string') # returns 'string'str([])       # returns '[]'str((1,2,3))  # returns '(1,2,3)'str(str)      # returns "<type 'str'>"# the following returns True # (compares literal string to Unicode string, #  see unicode type below)'' == u''    # useful methodsfoo = 'string'foo.capitalize()         # returns 'String'foo.center(9)            # returns '  string ', a string of length 10 with foo                          # centered as much as possiblefoo.count('str')         # returns 1, the no. of times that 'str' occurs in foofoo.decode()             # returns u'string'. You can specify an encoding to use                         # and error handling behavior.foo.encode()             # returns 'string'. " " " " "foo.endswith('ing')      # returns True, bc foo ends in 'ing'. 'ing' could also                          # be a tuple of strings to try.foo.expandtabs(90000)    # returns 'string'. This replaces tabs with 90000                          # characters; by default, leave blank for 8.foo.find('ing')          # returns 3, the lowest index where '                         # ing' is found in foofoo.isalpha()            # returns True, bc all chars in foo are alphabeticalfoo.isdigit()            # returns False, bc not all chars in foo are numericfoo.isalnum()            # returns False, bc foo does not contain at least 1                          # alphabetical char and at least 1 number (foo is not                          # alphanumeric)foo.islower()            # returns True, bc all chars in foo are lower casefoo.isupper()            # returns false, bc not all chars in foo are upper casefoo.istitle()            # returns false, bc foo's first char is not capitalized                         # ('String'.istitle() is True)foo.isspace()            # returns false, bc foo does not contain all whitespacefoo.join('123')          # returns '1string2string3' by using foo to join each                          # element in the iterable (can be any iterable!)foo.ljust(10)            # returns 'string    ', a string of length 10 with foo                          # left-justified in itfoo.lower()              # returns 'string', foo in lower casefoo.lstrip('str')        # returns 'ing' by removing whitespace or the input                          # string (which is 'str' here) from the left side of                          # the string, nowhere elsefoo.partition('ri')      # returns ('st','ri','ng') by getting what's left of                          # 'ri', 'ri' and what's right of 'ri'foo.replace('s', '5', 1) # returns '5tring' by replacing 's' with '5', a                          # maximum of 1 timefoo.rfind('ing')         # returns 3 by finding the highest index (as opposed to                         # lfind's lowest index) where 'ing' occurs in foofoo.rjust(10)            # returns '    string', a string of length 10 with foo                          # right-justified in itfoo.rpartition('ri')     # returns ('st', 'ri', 'ng') by starting from the right                         # finding 'ri' and getting it and the adjacent strings.foo.rsplit('ri', 1)      # returns ['st','ng'] by starting from the right,                          # finding 'ri' and splitting foo 1 timefoo.rstrip('ing')        # returns 'str' by starting from the right, finding                          # 'ing' and removing itfoo.split('ri', 1)       # returns ['st', 'ng'] by starting from the left,                          # finding 'ri' and splitting foo 1 time'\n1\n'.splitlines(True) # returns ['\n', '1\n'] by splitting at newlines. True                          # says 'keep newline chars', and is optional. By                          # default, newline chars are removed.foo.startswith('str')    # returns Truefoo.strip('st')          # returns 'ring'foo.swapcase()           # returns 'STRING' by swapping the case for each                          # character in foofoo.title()              # returns 'String' by capitalizing the first char and                          # lower-casing all other chars in foofoo.upper()              # returns 'STRING' by making all characters upper case                         # in foofoo.zfill(10)            # returns '0000string' by padding foo on the left                          # until a string of length 10 is made#-------------------------------------------------------------------------------# slice'''Create a slice object.     This is used for extended slicing (e.g. a[0:10:2]).      slice([start,] stop[, step]) --> slice object      http://docs.python.org/library/functions.html#slice   '''slice(5)        # returns slice(None, 5, None)slice(0, 5)     # returns slice(0, 5, None)slice(0, 5, 2)  # return slice(0, 5, 2)[0,1,2,3,4,5][slice(0,5,2)] # returns [0,2,4][0,1,2,3,4,5][0:5:2]        # returns [0,2,4]    # useful methodsfoo = slice(0, 10, 2)foo.indices(10)         # returns (0, 10, 2) by finding                         # (startIndex, endIndex, stride) in a sequence of length                        # 10foo.start               # returns 0foo.stop                # returns 10foo.step                # returns 2#-------------------------------------------------------------------------------# type'''type(object) --> the object's type   type(name, bases, dict) --> a new type      http://docs.python.org/library/functions.html#type   '''type('5')   # returns <type 'str'>type(5.0)   # returns <type 'float'>type(type)  # returns <type 'type'>if type(5.) == type(5.0): # True    '5. and 5.0 have the same type'#-------------------------------------------------------------------------------# unicode'''Create a new Unicode object from the given encoded string.   encoding defaults to the current default string encoding.   errors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.      unicode(string [, encoding[, errors]]) --> object      http://docs.python.org/library/functions.html#unicode   '''   # See this for help: http://docs.python.org/howto/unicode.htmlunicode('string')   # returns u'string'unicode(u'string')  # returns u'string'unicode(5)          # returns u'5'unicode(5.)         # returns u'5.0'    # useful methods -- shares many with str, with some notable additionsfoo = u'12345'foo.isdecimal()     # returns Truefoo.isnumeric()     # returns True#-------------------------------------------------------------------------------#                  ---DATA CONTAINERS/DATA STRUCTURES---# list'''list() --> new empty list   list(iterable) --> new list initialized from iterable's items      http://docs.python.org/library/functions.html#list   '''list()                            # returns []list((1,2,3))                     # returns [1, 2, 3]list('123')                       # returns ['1', '2', '3'][ [], [] ]                        # returns [[],[]], a list of lists[1, '1', 1., type, [], (,), u'']  # lists do not constrain type[1] + [2]                         # returns [1,2], NOT [3][1] * 5                           # returns [1,1,1,1,1]                                  # !NB: '+' and '*' are the only supported                                  # operands for lists; don't go trying to                                  # subtract, divide or modulate.                                  # This behavior also applies to tuples.    # slicing (applies to nearly all iterables!)[1, 2, 3][0]                      # returns 1, the element in the list at                                  # index 0[1, 2, 3][:2]                     # returns [1,2] by slicing the list in the                                  # half-open interval [0,2)[1, 2, 3][:-1]                    # returns [1,2] by retrieving everything                                  # left of the '-1' (last) element in the list[1, 2, 3][-3]                     # returns 1, the '-3' element in the list[1, 2, 3][:9000]                  # returns [1,2,3] -- no error raised in Py27[1, 2, 3][9000:]                  # returns [][1, 2, 3][9000]                   # returns indexError: list index out of range[1, 2, 3][::2]                    # returns [1,3] by stepping by 2    # useful methodsfoo = [] + []          # an empty list - rectangular brackets.foo.append(0)          # appends 5 to foo, foo becomes [0]foo.extend([1,2,3])    # appends 1, 2 and 3 to foo, foo becomes [0,1,2,3]foo.append([1,2,3])    # appends [1,2,3] to foo, foo becomes                        # [0, 1, 2, 3, [1,2,3]]foo.count(1)           # returns 1, the number of times 1 is in foofoo.index([1,2,3])     # returns 4, the first index with value [1,2,3]foo.insert(1, 999)     # inserts 999 before index 1, foo becomes                        # [0, 999, 1, 2, 3, [1,2,3]]foo.pop()              # remove and return last item from foo, [1,2,3]. foo                        # becomes [0, 999, 1, 2, 3]foo.remove(999)        # remove first occurrence of 999, foo becomes                        # [0, 1, 2, 3]foo.reverse()          # reverse foo in-place, foo becomes [3, 2, 1, 0]foo.sort()             # sort foo in-place, foo becomes [0, 1, 2, 3]foo.sort(reverse=True) # sort foo in-place in reverse order, foo becomes                        # [3, 2, 1, 0]#-------------------------------------------------------------------------------# dict'''dict() -> new empty dictionary      dict(mapping) -> new dictionary initialized from a mapping object's   (key, value) pairs      dict(iterable) -> new dictionary initialized as if via:   d = {}   for k, v in iterable:       d[k] = v          dict(**kwargs) -> new dictionary initialized with the name=value pairs   in the keyword argument list.  For example:  dict(one=1, two=2)      Author: Dictionaries are extremely powerful tools because they can           use any object as a key to any value. This makes them great           for crosswalks, lookup tables and simple caching. Note well           that because dictionary keys are unique and unordered, they           have set-like properties, meaning they are good for fast           lookups (i.e. '1' in {1:2} is fast) but they are bad for           order-based logic. For that, use `collections.OrderedDict`.              http://docs.python.org/library/stdtypes.html#dict   '''dict()              # returns {}, an empty dictionarydict((1,2), (3,4))  # returns {1:2, 3:4}{1:2, 3:4}[3]       # returns 4, the 'value' linked to the 'key' 3                    # note that dictionary keys are unique, but values                    # can be any object!{1:2, 3:4}[5] = 6   # gives this dict a key 5 that links to a value 6,                     # becomes {1:2, 3:4, 5:6}    # useful methodsfoo = {}                   # an empty dictionaryfoo.clear()                # clear foo...no changes herefoo.copy()                 # returns a 'shallow' copy of foofoo.update([(1,2), (3,4)]) # foo gains {1:2, 3:4}, becoming {1:2, 3:4}foo.update([(5,6)])        # foo gains {5:6}, becoming {1:2, 3:4, 5:6}foo.get('I')               # returns None, bc 'I' is not a key in foofoo.get('I', 5)            # returns 5, bc 'I' is not a key in foofoo.get(3, 5)              # returns foo[3], which is 4. Nothing happens with 5foo.get(3)                 # returns foo[3], which is 4foo.setdefault('I', 40)    # returns foo.get('I',40) and sets foo['I'] to 40 if                           # 'I' is not a key of foo (which it is not) so foo                           # becomes {1:2, 3:4, 5:6, 'I':40}foo.has_key('I')           # returns true bc foo contains 'I' as a keyfoo.keys()                 # returns the keys of foo in a sorted list; returns                           # ['I', 1, 3, 5]foo.values()               # returns the values of foo, sorted by key; returns                           # [40, 2, 4, 6]foo.items()                # returns key:value pairs in foo, sorting by key:                           # [('I',40), (1,2), (3,4), (5,6)]foo.pop('I')               # return foo['I'] then remove foo['I']; foo becomes                           # {1:2, 3:4, 5:6}foo.pop('I', 5)            # return 5 because 'I' is not a key of foofoo.pop('I')               # raise KeyError because 'I' is not a key of foo                           # and the optional backup argument (5, above) is                           # unspecified# foo.iteritems(), foo.iterkeys(), foo.itervalues() -- iterator objects# foo.viewitems(), foo.viewkeys(), foo.viewvalues() -- set-like objects#-------------------------------------------------------------------------------# tuple'''tuple() -> empty tuple   tuple(iterable) -> tuple initialized from iterable's items   If the argument is a tuple, the return value is the same object.      Author: Tuples are immutable. Immutability is useful when you don't need to            change the contents of a collection of data. You cannot add or remove            contents from a tuple, and you cannot change elements once assigned.           If you need those capabilities, consider using a list, set or dict.              http://docs.python.org/library/functions.html#tuple   '''tuple()               # returns empty tuple()                    # returns empty tuple(1)                   # returns 1, an integer!(1,)                  # returns (1,) a tuple! the comma is key!(,)                   # in Python 2.7, raises SyntaxErrortuple([1,1])          # returns (1, 1)tuple({1:2, 3:4})     # returns (1, 3) using the dict's keysa, b = (1, 2)         # a becomes 1, b becomes 21, 2, 3               # returns (1, 2, 3)tuple( ((1),(2)) )    # returns (1, 2)tuple( ((1,),(2,)) )  # returns((1,), (2,)) where (1,) and (2,) are tuples                       # inside foo(1, 2) + (3, 4)       # returns (1, 2, 3, 4)(1,) * 5              # returns (1, 1, 1, 1, 1)                      # '+' and '*' are the only valid operands for tuples;                      # this behavior also applies to lists.    # useful methodsfoo = (1, 1, 3, 3)  # foo is (1,2,3,3)foo.count(1)        # returns 2, the number of times 1 is in foofoo.index(3)        # returns 2, the index of the first occurrence of 3 in foo#-------------------------------------------------------------------------------# set'''set() -> new empty set object   set(iterable) -> new set object   Build an unordered collection of unique elements.      http://docs.python.org/library/stdtypes.html#set   '''set()                # returns an empty set, set()set([1,2])           # returns set([1,2])set([1,1,2,2])       # returns set([1,2])set(1)               # returns TypeError: 'int' object is not iterable. The                      # argument to set() must be iterable.set({1:2, 3:4})      # returns set([1,3]) using the dict's keysset([1, '1', 1.0])   # returns set([1, '1'])    # useful methodsfoo = set([1,2,3])foo.add(4)          # adds 4 to foo; foo becomes set([1,2,3,4])foo.add(4)          # does nothing bc 4 is already in foofoo.remove(4)       # removes 4 from foo; foo becomes set([1,2,3])foo.remove(4)       # raise KeyError: 4 because 4 is no longer in foofoo.discard(4)      # attempt to remove 4 from foo; do not raise error if 4 is                    # not a member of foofoo.pop()           # returns an 'arbitrary' element from foo and then removes                    # it from foo. raises KeyError if the set is empty.foo.clear()         # remove all elements from foo; foo becomes set()foo.update([1,2,3]) # make sure we know what foo is; foo becomes set([1,2,3])foo.union([4,5,6])  # returns the union of foo and [4,5,6], which is                    # set([1,2,3,4,5,6]). Does not change foo!foo.difference([1,2,3])                # returns set(), a set containing                                        # elements in foo that                                       # are not in [1,2,3]foo.difference([1])                    # returns set([2, 3])foo.difference([1], [2,3])             # returns set() -- note multiple                                       # argumentsfoo.difference_update([1], [2])        # foo becomes set([3])foo.symmetric_difference([1,2])        # returns set([1,2,3]), the elements                                        # that are                                       # in exactly ONE setfoo.symmetric_difference_update([1,2]) # foo becomes set([1,2,3])foo.issubset([1,2,3,4])      # returns True bc foo is a subset of [1,2,3,4]foo.issuperset([1,2])        # returns True bc foo contains [1,2]foo.isdisjoint([5,6,7])      # returns True bc foo and [5,6,7] do not intersectfoo.isdisjoint([1,2])        # returns False bc foo and [1,2] intersectfoo.intersection([1], [1,2]) # returns set([1]), a set with the elements that                             # are members of foo, [1] and [1,2]foo.intersection([1], [2,3]) # returns set() bc no elements are in all 3 setsfoo.intersection([1])        # returns set([1])foo.intersection_update([1]) # foo becomes its intersection with [1], which is                             # set([1])#-------------------------------------------------------------------------------# frozenset'''frozenset() -> empty frozenset object   frozenset(iterable) -> frozenset object   Build an immutable unordered collection of unique elements.      Author: A frozenset is immutable, meaning that -- just as with tuples -- you           cannot add, remove or change the set's elements. This means that many           of the methods available for normal sets do not apply to frozensets.              http://docs.python.org/library/stdtypes.html#frozenset   '''frozenset()         # returns an empty frozenset, frozenset()frozenset([1,2,3])  # returns frozenset([1,2,3])frozenset([1,1,1])  # returns frozenset([1])    # useful methods# See the 'set' section for frozenset's methods:# difference, intersection, isdisjoint, issubset, issuperset,# symmetric_difference, union#===============================================================================#   FUNCTIONS#===============================================================================# all  # abs              # apply            # any              # bin              # callable         # chr              # cmp              # coerce           # compile          # delattr          # divmod           # dreload          # execfile         # filter           # format           # getattr          # globals          # hasattr          # hash             # hex              # id               # intern           # isinstance       # iter             # len              # locals           # map              # max              # min              # next             # oct              # open             # ord              # pow              # range            # raw_input        # reduce           # reload           # repr             # round            # setattr          # sorted           # sum              # unichr           # vars             # zip#===============================================================================#   OTHER TYPE-FUNCTION OBJECTS#===============================================================================# classmethod'''Convert a function to be a class method.      A class method receives the class as implicit first argument,   just like an instance method receives the instance.   To declare a class method, use this idiom:        class C:         def f(cls, arg1, arg2, ...): ...         f = classmethod(f)      It can be called either on the class (e.g. C.f()) or on an instance   (e.g. C().f()).  The instance is ignored except for its class.   If a class method is called for a derived class, the derived class   object is passed as the implied first argument.      Class methods are different than C++ or Java static methods.   If you want those, see the staticmethod builtin.      classmethod(function) -> method      Author: See 'http://stackoverflow.com/questions/38238/                       what-are-class-methods-in-python-for'           See 'http://stackoverflow.com/questions/136097/                       what-is-the-difference-between-staticmethod-and-                       classmethod-in-python'                          http://docs.python.org/library/functions.html#classmethod   '''class MyClass():        def f(cls, x):  # notice implicit first argument with special syntax, 'cls'        return x * x            f = classmethod(f)    MyClass.f(5)            # returns 25instance = MyClass()    # save an instance of the classinstance.f(5)           # returns 25, same as MyClass().f(5)#-------------------------------------------------------------------------------# enumerate# http://docs.python.org/library/functions.html#enumerate#-------------------------------------------------------------------------------# file'''Open a file.  The mode can be 'r', 'w' or 'a' for reading (default),   writing or appending.  The file will be created if it doesn't exist   when opened for writing or appending; it will be truncated when   opened for writing.  Add a 'b' to the mode for binary files.   Add a '+' to the mode to allow simultaneous reading and writing.   If the buffering argument is given, 0 means unbuffered, 1 means line   buffered, and larger numbers specify the buffer size.        NB:   The preferred way to open a file is with the builtin open() function!      Add a 'U' to mode to open the file for input with universal newline   support.  Any line ending in the input file will be seen as a '\n'   in Python.  Also, a file so opened gains the attribute 'newlines';   the value for this attribute is one of None (no newline read yet),   '\r', '\n', '\r\n' or a tuple containing all the newline types seen.      'U' cannot be combined with 'w' or '+' mode.      file(name[, mode[, buffering]]) -> file object      http://docs.python.org/library/functions.html#file   '''#-------------------------------------------------------------------------------# reversed# http://docs.python.org/library/functions.html#reversed#-------------------------------------------------------------------------------# staticmethod'''Convert a function to be a static method.   A static method does not receive an implicit first argument.   To declare a static method, use this idiom:           class C:        def f(arg1, arg2, ...): ...        f = staticmethod(f)      It can be called either on the class (e.g. C.f()) or on an instance   (e.g. C().f()).  The instance is ignored except for its class.      Static methods in Python are similar to those found in Java or C++.   For a more advanced concept, see the classmethod builtin.      staticmethod(function) -> method      AUTHOR: See 'http://stackoverflow.com/questions/136097/                       what-is-the-difference-between-staticmethod-and-                       classmethod-in-python'   '''class MyClass():    def f(x):           # notice no implicit first argument        return x * x            f = staticmethod(f)    MyClass.f(5)         # returns 25instance = MyClass() # save an instance of the classinstance.f(5)        # returns 25#-------------------------------------------------------------------------------# super# http://docs.python.org/library/functions.html#super#-------------------------------------------------------------------------------# xrange# http://docs.python.org/library/functions.html#xrange